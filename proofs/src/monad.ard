\import Paths
\import list
\import monoid
\import funs
\import sets

\record TypeConstr (F : \Set  -> \Set  )

\record Functor \extends TypeConstr {
  | map : \Pi {A B : \Set} -> F A -> (A -> B)  -> F B
  | identity : \Pi { A : \Set } (fa : F A) -> map fa (\lam x => x) = fa
  | composition : \Pi { A B C : \Set } (fa : F A) (f : A -> B) (g : B -> C) -> map fa (g ~ f) = map (map fa f) g
}

\record BaseMonad \extends TypeConstr {
  | pure : \Pi {A : \Set } -> A -> F A
  | flatMap : \Pi {A B : \Set } -> F (A) -> (A -> F B) -> F B
  \property left_unit : \Pi { A B : \Set } (a : A) (f : A -> F B) -> flatMap (pure a) f = f a
  \property right_unit : \Pi { A : \Set } (fa : F A) -> flatMap fa pure = fa
  \property associativity : \Pi { A B C : \Set} (fa : F A) (f : A -> F B) (g : B -> F C) ->
      flatMap fa (\lam x => flatMap (f x) g) = flatMap ( flatMap fa f ) g
}

\record Monad \extends BaseMonad , Functor {
  | map fa f => flatMap  fa (\lam x => pure (f x))
  | identity => right_unit
  | composition {_} {_} {C}  fa f g =>
    \let | gp x => pure (g x)
         | lu_extended => funExt (\lam _ => F C) gp (\lam b => flatMap (pure b) gp) (\lam b => inv ( left_unit b gp))
    \in pmap (\lam u => flatMap fa (u ~ f)) lu_extended *>  associativity fa (pure ~ f) gp
}

\record BaseFlattenMonad \extends Functor {
  | flatten : \Pi {A : \Set}  -> F (F A) -> F A
  \property l-unit : \Pi{A : \Set} (f : F A) -> map
}

