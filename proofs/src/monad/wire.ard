\import Paths
\import monad
\import monoid
\open Semigroup (|+|)
\open Monoid (emp)

\data Socket (S : \Type) (A : \Type)
  | vacant S
  | full  S A \where {
  \func addL {S A : \Type} {sg : Semigroup S} (s1 : S) (sock : Socket S A) : Socket S A =>
    \case sock \with {
      | vacant s2 => vacant (s1 |+| s2)
      | full s2 a => full (s1 |+| s2) a
    }

  \func addLlu {S A : \Type} {m : Monoid S} (sock : Socket S A) : addL emp sock = sock \elim sock
    | vacant s => pmap vacant (m.left_unit s)
    | full s a => pmap (\lam x => full x a) (m.left_unit s)
}

\func socketMonad (S : \Set) {smon : Monoid S} : Monad (Socket S) \cowith
  | pure a => full emp a
  | flatMap sa => flmap sa
  | left_unit a f => Socket.addLlu (f a)
  | right_unit sa => runit sa
  | associativity {A} fa f g =>
    \let eqfa fa' => flmap fa' (\lam x => flmap (f x) g) = flmap (flmap fa' f) g
    \in \case fa \as sock, idp : sock = fa \with {
      | vacant s , efa => transport eqfa efa idp
      | full s a , efa =>
        \let | eqf f_a' => Socket.addL s (flmap f_a' g) = flmap (Socket.addL s f_a') g
             | H1 : eqf (f a) => \case f a \as f_a, idp : f_a = f a \with {
               | vacant s1, ef_a => transport eqf ef_a idp
               | full s1 b, ef_a =>
                 \let | eqg g_b => Socket.addL s (Socket.addL s1 g_b) = Socket.addL (s |+| s1) g_b
                      | H2 : eqg (g b) => \case g b \as g_b, idp : g_b = g b \with {
                        | vacant s2 , eg_b => transport eqg eg_b (pmap vacant (inv (smon.associativity s s1 s2)))
                        | full s2 c, eg_b => transport eqg eg_b (pmap (\lam s' => full s' c) (inv (smon.associativity s s1 s2)))
                      }
                 \in transport eqf ef_a H2
             }
        \in  transport eqfa efa H1
    }
  \where {
    \func flmap {S A B : \Type}  {smon : Monoid S} (sa : Socket S A) (f : A -> Socket S B) : Socket S B \elim sa
      | vacant s => vacant s
      | full s a => Socket.addL s (f a)

    \func runit {S A : \Type} {smon : Monoid S} (sa : Socket S A) : flmap sa (full emp) = sa \elim sa
      | vacant s => idp
      | full s a => pmap (\lam x => full x a) (smon.right_unit s)
  }

\func wireMonad (S : \Set) : Monad (\lam A => S -> Socket S A) \cowith
  | pure a s => full s a
  | flatMap wa fab s => cont (wa s) fab
  | left_unit a f => idp
  | right_unit {A} wa =>
    \let eqvt x =>   cont x pur = x
    \in funExt (\lam _ => Socket S A) (_) (_) (
      \lam s => \case wa s \as was, idp : was = wa s  \with {
        | vacant s1, e => transport eqvt e idp
        | full s1 b, e => transport eqvt e idp
      })
  | associativity {A} {B} {C} wa f g =>
    \let eqvt x => cont x (\lam x s => cont (f x s) g) = cont (cont x f) g
    \in funExt (\lam _ => Socket S C) (_) (_) (
      \lam s => \case wa s \as was, idp : was = wa s \with {
        | vacant s, e => transport eqvt e idp
        | full s b, e => transport eqvt e idp
      })
  \where {
    \func pur {S A : \Type } (a : A) (s : S) : Socket S A => full s a

    \func ctr  (S A : \Type) => S -> Socket S A

    \func flmap {S A B : \Type} (wa : ctr S A) (fab : A -> ctr S B) (s : S) : Socket S B => cont (wa s) fab

    \func cont {S A B : \Type} (was : Socket S A) (fab : A -> ctr S B)  : Socket S B => \case was \with{
      | vacant s1 => vacant s1
      | full s1 a => fab a s1
    }
  }

\func wireTMonad (S : \Set) (X : \Set -> \Set) {fm : Monad X} : Monad (\lam A => S -> Socket S A) \cowith
  | pure => {?}
  | flatMap => {?}
  | left_unit => {?}
  | right_unit => {?}
  | associativity => {?}
